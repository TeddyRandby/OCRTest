import path from "path";
import getJSON from "./parser";
import psm from "../PSM/psm";

const rules = {
    "Start > Header": (from, to, acc) => {
      acc.header.push(to.ocr_text);
      to.pointer = 0;
      return to;
    },
    "Start > Content": (from, to, acc) => {
      acc.content.push(to.ocr_text);
      to.pointer = 0;
      return to;
    },
    "Start > Stamp": (from, to, acc) => {
        acc.stamp = to.ocr_text;
        return from;
    },
    "Start > *": (from, to, acc) => {
      return from;
    },
    "Header > Date": (from, to, acc) => {
      var obj = {};
      obj[to.ocr_text] = from.pointer;
      acc.dates.push(obj);
      return from;
    },
    "Header > Index": (from, to, acc) => {
      var obj = {};
      obj[to.ocr_text] = from.pointer;
      acc.indexes.push(obj);
      return from;
    },
    "Header > Header": (from, to, acc) => {
      acc.header[from.pointer] += to.ocr_text + " ";
      to.pointer = from.pointer;
      return to;
    },
    "Header > Stamp": (from, to, acc) => {
      acc.Stamp = to.ocr_text;
      return from;
    },
    "Header > Content": (from, to, acc) => {
      acc.content.push(to.ocr_text);
      to.pointer = from.pointer + 1;
      return to;
    },
    "Content > Date": (from, to, acc) => {
      var obj = {};
      obj[to.ocr_text] = from.pointer;
      acc.dates.push(obj);
      if (acc.content[from.pointer] != undefined) from.pointer += 1;
      return from;
    },
    "Content > Index": (from, to, acc) => {
      var obj = {};
      obj[to.ocr_text] = from.pointer;
      acc.indexes.push(obj);
      return from;
    },
    "Content > Header": (from, to, acc) => {
      return to;
    },
    "Content > Stamp": (from, to, acc) => {
      acc.Stamp = to.ocr_text;
      return from;
    },
    "Content > Content": (from, to, acc) => {
      if (acc.content[from.pointer] == undefined)
        acc.content[from.pointer] = "";
      acc.content[from.pointer] += to.ocr_text += " ";
      return from;
    },
    "* > Handwritten": (from, to, acc) => {
      acc.handwritten = true;
      return from;
    },
  }
const sorter = (a, b) => {
    if (a.ymin - b.ymin < -10) {
      return -1;
    } else if (a.ymin - b.ymin > 10) {
      return 1;
    } else if (a.xmin < b.xmin) {
      return -1;
    } else if (a.xmin > b.xmin) {
      return 1;
    } else {
      return 0;
    }
  }

export function process() {
  var data = getJSON(path.join(__dirname + "/NewData.json"));
  var keys = Object.keys(data);
  for (var key in keys) {
    data[keys[key]] = JSON.parse(data[keys[key]]);
  }

  for (var key in keys) {
    var curr = data[keys[key]];
    curr.result.forEach((res) => {
        // Iterating through each card:
      if (res.message == "Success") {
        // process sorted predictions with PSM
        res.parsed = psmProcess()(res.prediction);

        // turn the pointers generated by the machine for indexes and dates
        //  into the content they point to.
        var cnt = res.parsed.header.concat(res.parsed.content);
        res.parsed.indexes.map(obj=>{
            Object.keys(obj).forEach(key=>{
                obj[key] = cnt[obj[key]];
            })
        });
        res.parsed.dates.map(obj=>{
            Object.keys(obj).forEach(key=>{
                obj[key] = cnt[obj[key]];
            })
        });
        
        // return the response, with a new parsed field!
        return res;
    } else {
        return res;
      }
    });
  }
  return data;
}

function psmProcess() {
 return psm(
    rules,
    (datum) => datum.label,
    { label: "Start" },
    { header: [], content: [], indexes: [], dates: [], handwritten:false },
    sorter
  );
}
